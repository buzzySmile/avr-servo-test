#include "../include/EERTOS.h"
#include "../include/servo.h"

ISR(SERVO_ISR)
{
if (servo_state)				// Если не нулевое состояние то
	{
	// Таймер-1: OCR1A = ServoNextOCR[servo_state];	
	OCR0 = ServoNextOCR[servo_state];			// В регистр сравнения кладем следующий интервал
	SERVO_PORT &= ~ServoPortState[servo_state];	// Сбрасываем биты в порту, в соответствии с маской в массиве масок.
	servo_state++;								// Увеличиваем состояние автомата
				
	if (OCR0 == 0xFF)							// Если значение сравнения равно FF значит это заглушка
	//Таймер-1: if (OCR1A == 0xFFFF)	
		{										// И мы достигли конца таблицы. И пора обнулить автомат
		servo_state = 0;						// Выставляем нулевое состояние.

		TCNT0 = 105;							// Программируем задержку в 20мс (на предделителе 1024)
		TCCR0 &= 0b11111000;
		TCCR0 |= 0b00000101;
		// Таймер-1: TCNT1 = 0x9E58;			// Программируем задержку в 20мс (на предделителе 1024)
		/* Манипуляции с предделителем на таймер 1
		TCCR1B &= 0b11111000;					// Сбрасываем предделитель
		TCCR1B |= 0b00000011;					// устанавливаем предделитель CS11:0=1:1(Freq = clkT2S/64)
		*/
		if (servo_need_update)					// Если поступил приказ обновить таблицы автомата
			{
			updServo();							// Обновляем таблицы.
			servo_need_update = 0;				// Сбрасываем сигнал обновления.
			}
		}
	}
else											// Нулевое состояние автомата. Новый цикл
	{
	OCR0 = ServoNextOCR[servo_state];			// Берем первую выдержку.
	//Таймер-1: OCR1A = ServoNextOCR[servo_state];		// Берем первую выдержку.
	TCCR0 &= 0b11111000;
	TCCR0 |= 0b00000100;
	/* Манипуляции с предделителем на таймер 1
	TCCR1B &= 0b11111000;						// Сбрасываем предделитель
	TCCR1B |= 0b00000011;						// устанавливаем предделитель CS11:0=1:1(Freq = clkT2S/64)
	*/
	SERVO_PORT = 0xFF;							// Выставялем все сервоканалы в 1 - начало импульса
 
	servo_state++;								// Увеличиваем состояние конечного автомата.
	}
}
