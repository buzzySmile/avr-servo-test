//************************************************
//		    		inttimer.c					//
//************************************************
#include "../include/EERTOS.h"

/*
Служба таймеров ядра. Должна вызываться из прерывания раз в 1мс.
Хотя время можно варьировать в зависимости от задачи

To DO: 
Привести к возможности загружать произвольную очередь таймеров. 
Тогда можно будет создавать их целую прорву. 
А также использовать эту функцию произвольным образом. 
В этом случае не забыть добавить проверку прерывания. 
*/
//RTOS Interrupt
ISR(RTOS_ISR)			//? RTOS_ISR = TIMER2_COMP_vect -- это прерывание по сравнению таймера-2
{
 u08 index;
 // Разрешаем тут прерывания, потому как конечный автомат управления сервами не должен споткнуться без прерывания
 Enable_Interrupt;

 // Прерывание ядра диспетчера
 for(index=0;index!=MainTimerQueueSize+1;index++)		// Прочесываем очередь таймеров
	{
	if(MainTimer[index].GoToTask == Idle) continue;		// Если нашли пустышку - щелкаем следующую итерацию

	if(MainTimer[index].Time !=1)						// Если таймер не выщелкал, то щелкаем еще раз. 
		{												// To Do: Вычислить по тактам, что лучше !=1 или !=0. 
		  MainTimer[index].Time --;						// Уменьшаем число в ячейке если не конец.
		}
	else
		{
		  setTask(MainTimer[index].GoToTask);			// Дощелкали до нуля? Пихаем в очередь задачу
		  MainTimer[index].GoToTask = Idle;				// А в ячейку пишем затычку
		}
	}
}
